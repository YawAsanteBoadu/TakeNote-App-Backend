Folder Structure 
MVC(S-R)
----------
1st folder: config
> this folder holds every configuration of the project
files under config:
1st. env.js:
> in other to avoid numerous import of the dotenv package, is best to create this file and import it once and for all.
> under seperation of concern; it is good to move the package imported and its configuration into this evn.js and then export it for whatever file might need to import it.
> inside this file, create a javascript object and construct all data as attribute of the ENV object.
> anytime you need to use the information here, you just have to import it and the destructure what you need from it.
> eg: Now we need the port number stored inside .env at server.js for the server to run; all that we need to do is to import the env.js in sever.js and the destructure the ENV object to access the port number.  *easy pizzy*
> note: ENV is the object, anytime you need some from the object you call it this way (ENV.(i need this))



    *ended with 01BestPractice Video


** ejs can help you build and express application which can render UI

Packages 
1st package: package.json
> manage or keep track of all the dependancies which the project might rely on
> whenever you install a package, you will see that it has been added to the dependancy object in the package.json
how to intall: npm install -y (y stand for yes, to skip to the end)

2nd package: express server
> by installing express the node_module folder will come along but do not add it to your github repo
> reason: every developer who clones your project can intall it back.
> backend functionalities sit on server and we use express to create a server for javascript apps
* setting up the server
1st file: app.js
>app.js is not going to start the server but it will be containing the structure or scapfold of how the server is working
> it contains the logic of how the server works or response to other stuffs
*most commonly, it is used to make examplily server configuration in videos and other contents but in real standard project it is not used as such.* 
> best practice: import express here; create an instance of express here(const app = express()) then you export it out to server.js
2nd file: server.js
> this will be the file to contain anything about starting the server, starting the database or connecting to the database. 

3rd Package: dotenv
> best practice: it is best to avoid hard coding every piece of data that your application depends on to run. basically some secret information as port number for starting the application, and database configurations...
*using dotenv to keep it safe🔐
> create a file in the main directory named; ".env"
> import dotenv in the server.js file
> then you configure it by (dotenv.config)
> the configuration logic above is what enables the package to look for the .env file and load it for where it is needed *import and configuration location will change as a result of best practice*
> regardless the work of the .config() you still need to access the content inside .env file using a global viariable in nodeJS called "process"
*the global variable called process: refers to any nodejs server which running within your machine*
> note: every content in .env file is an object with a key:value pair
*how to install: npm install dotenv 

4th Package: nodemon♻️
# by default any changes that we make to the server does not take effect automatically. 
helps to develop node application; it automatically restart the server when it dictects changes in any file

* Package Managers in Javascript
1. npm: you can find all dependancies you need to build your node.js projects
2. yarn ✅
3. pnpm ✅

* npx: node package executor 
* nvm: node version manager

* two module systems in Javascript
> common Js
> ECMA SCRIPT ES6
by default nodeJS uses common js
how to change to ECMA script: in the package.json set the value of type to "module"


*seperation of concern says, code should be kept in seperate files as they handle a single task. !! don't put your code togther!!*


                                *2nd Lesson*

    *Planning Endpoint*
1. Create API VERSION
> /api/v1
users 
=> any endpoint that any user wants to hit will have to be prefixed with usres: eg. localhost:4000/users/signup
=> *building a project you have to think about the project going to scale, you have to think about seperation o f concern as well*
for instnace if you use localhost:4000/signup as user signup endpoint; what will you do if you get to a point where there is a need for admin special route. Then you have to use the same endpoint up there for all routing which is know as generic route; makes your code to hard to maintian and scale.   
=> for some reasons like mandatory details for user signup or logins, you have to think of versioning your API. 
=> what instutions do is that, they give newer versions to new users and slowly they transition from older to newer, otherwise changing it all at once may break things. 

*Brief on Middleware*
=> Middleware is anything that sits between request and response. 
Proxy Server is also related to Middleware:
1. Forward Proxy 
2. Reverse Proxy
In Express it is called use()

*Case Study Example*
1. app.post("/api/v1/user/signup", (req, res) => {
    res.send("Sign Up Successgul 👏")
})

2. app.post("/api/v1/user/login", (req, res) => {
    res.send("Login Successful 👏")
})

=> from the above code:
1. we are repeating ourselves in so many ways
-> "api/v1" has been repeated in both route
-> "/user" has also been repeated in both route
2. Looking at the case study, you can notice that anything that has the nature of "users", eg. note, reminder and so on. They hold the need to have thier own routes. This means that as we are repeating users, the same way that we are going to be repeating these things. When it happens so our becomes to much to maintain. In other words, it is bad. 
*Best Practice*
-> We can create a constant variable for currunt api and the we assign the current version to it. (const API_Version = "/api/v1")
-> We can use middleware to help avoid too many repetition of route. 
# How to achive it;
1. To put them in seperate files
    -> any route that is about users will be kept is a sperate file
    -> any route that is about notes will be kept in a sperate file
    -> any route that is about reminder will be kept in a seperate file
2. Put all files above in a seperate folder name *routes* becuause it is keeping files that are holding routes to some features of the software.
🥇1st File: user.route.js
This file will contain everything about user endpoint
-> We will setup all user endpoint here, then we import it at app.js

=> 2nd File: note.route.js
This file will contain every about note endpoint.
# Express Router
-> This is a library of NodeJS that allows you to seperate your route into different files. 

=> 3rd File: index.js for cleaner code
* Created `index.js` to serve as a central entry point for all application routes.
* Exported all individual route modules (e.g., user, auth) from `routes/index.js`.
* Modified `app.js` to import and utilize only the `routes/index.js` module.
* Streamlines `app.js` and improves route management by centralizing route definitions.
`in javascript, when a folder is imported, it looks for the defualt file in it. which is why we are able to use index.js how we are using it`